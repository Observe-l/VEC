from asyncio import tasks
import numpy as np
import random
from util.Task import Task

class pretrainEnv:
    def __init__(self):
        # state1 
        self.b = 2
        self.u = 0.1
        self.G_total = self.get_G_total()
        self.Gb_bar = self.get_Gb_bar()
        self.Vehicle_density = self.get_vehicle_density()
        self.Gb = self.get_Gb()  #state1 global resource

        #state 3
        self.get_Ntr()    #state2 transactions generated by BS



        self.Tn = 4 #maximun tolerance delay

        self.compute_efficiency =  np.zeros(self.b)
        self.omega1 = 0.8  #range from[0,1]
        self.completion_ratio = np.zeros(self.b)
        self.total_received_task = np.zeros(self.b)
        self.omega2 = 0.8
        # self.reliability = self.get_reliability() #state3 reliability
        self.normalized_utility = np.zeros(self.b)
        self.t_delay = np.zeros(self.b)
        self.delay_list = [0.5,1,2]
        self.reliability = np.zeros(self.b)

        #action parameters
        self.maximum_block_size = 8 #40/5=8

        #reward parameters
        self.epsilon1 = 0.4
        self.epsilon2 = 0.6
        self.maximum_tolerance_dalay = 2
        self.gamma = -50
        self.reward = 0


    def get_Gb_bar(self):
        '''
        range from[0.0,10.0)
        @param b: the number of station
        @return: the computing resource reserved for non-vehicular computering
        '''
        return np.random.uniform(0,10,(self.b,))

    def get_G_total(self):
        '''
        range from[20.0,29.0]
        @param b: the number of station
        @return: the computing resource reserved for non-vehicular computering
        '''
        return np.random.uniform(20, 29, (self.b,))


    def get_vehicle_density(self):
        '''
        range from[5.0,40.0]
        @param b: the number of station
        @return: the density of vehicle around each base station
        '''
        return np.random.uniform(0, 4, (self.b,))

    def get_Gb(self):
        '''
        @return: available computing resource
        '''
        Gb =self.G_total-(self.Gb_bar+self.u*self.Vehicle_density)
        return Gb

    def get_Ntr(self):
        '''
        range from (0:10]
        @return: Ntr
        '''
        num =np.random.randint(2,5)
        self.Ntr=np.array([num])
        return 

    def update_Ntr(self):
        num =np.random.randint(2,5)
        self.Ntr=np.array([num])
        return


    def get_t_delay(self):
        '''
        range from[0.1,11]
        @param b: the number of station
        @return: the delay of base station
        '''
        return np.random.uniform(0.1, 11)


    def get_normalized_utilization(self,task):
        '''
        @return: normalization_utilization
        '''
        Ib = task.allocation_basestation_id
        difference = self.Tn-task.delay
        if difference<0:
            self.normalized_utility[Ib]=0
        else:
            self.normalized_utility[Ib] = np.log(1+difference)/np.log(1+self.Tn)
        return

    def update_compute_efficiency(self,task):
        '''
        update the compute efficaiency according to normalized utility and previous compute efficiency
        @return:
        '''
        Ib = task.allocation_basestation_id
        self.compute_efficiency[Ib] = (1-self.omega1)*self.compute_efficiency[Ib]+self.omega1*self.normalized_utility[Ib]
        return


    def update_total_received(self,Ib):
        self.total_received_task[Ib]+=1
        return


    def update_completion_ratio(self,task):
        Ib = task.allocation_basestation_id
        one = 1 if self.t_delay[Ib]<self.Tn else 0
        self.total_received_task[Ib] += 1
        self.completion_ratio[Ib] = ((self.total_received_task[Ib])*self.completion_ratio[Ib]+one)/self.total_received_task[Ib]
        return

    def update_reliability(self,task):
        Ib = task.allocation_basestation_id
        self.reliability[Ib] = self.omega2 * self.compute_efficiency[Ib] + (1 - self.omega1) * self.completion_ratio[Ib]
        return 

    def get_verify_time1(self):
        return np.random.uniform(15, 30)

    def get_verify_time2(self):
        return np.random.uniform(10, 21)


    def get_reward(self, Ib,delay):
        Sbk = 8
        #TODO: the delay should be got from real blockchain
        if delay > self.maximum_tolerance_dalay:
            self.reward = -50
        else:
            self.reward = (self.epsilon1 * self.reliability[Ib] + self.epsilon2 * Sbk / 2.0) * (
                    1 + self.maximum_tolerance_dalay - delay)
        self.reward = np.float(self.reward)
        return self.reward

    def updataBSByTasks(self,num):
        for i in range(num):
            task = Task()
            #generate fake data
            task.allocation_basestation_id=np.random.randint(0,2)
            task.delay= self.delay_list[np.random.randint(0,3)]
            task.done_status = np.random.randint(0,2)
            #update state
            #get normalized utulity
            nu = self.get_normalized_utilization(task)
            #update computing efficiency
            self.update_compute_efficiency(task)
            #update completion ratio
            self.update_completion_ratio(task)
            #update reliability
            self.update_reliability(task)
        return







            
