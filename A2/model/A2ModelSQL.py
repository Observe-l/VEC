from A2.util.BSSQLUtil import *
import numpy as np
from A2.util.BaseStationTransfer import *
from A2.util.TaskSQLUtil import *

import numpy as np


class A2EnvExtreme:
    def __init__(self):

        resetDB()
        # get the basestation model
        baseStationsDF = selectAll()
        self.baseStations = BSDF2BS(baseStationsDF)
        self.b = len(self.baseStations)  # number of base station
        self.u = 0.1

        # state1 global resource
        self.G_total = np.array([self.baseStations[i].global_computing_resource for i in range(self.b)])
        self.Gb_bar = np.array([self.baseStations[i].reversed_computing_resource for i in range(self.b)])
        #TODO: get the real-time vehicle desnsity from sumo
        self.Vehicle_density = np.array([40, 5])
        self.Gb = self.get_Gb()  # state1 global resource

        # state2 reliability
        self.Tn = [4,4,4] #maximun tolerance delay
         # get from zequn
        self.omega1 = 0.8  # range from[0,1]
        self.omega2 = 0.8
        # self.reliability = self.get_reliability() #state3 reliability
        self.reliability = np.array([self.baseStations[i].reliability for i in range(self.b)])

        # state3 transactions generated by BSs
        self.Ntr = self.get_Ntr()

        # action parameters
        self.maximum_block_size = 10  # 10/5=2

        # reward parameters
        self.epsilon1 = 0.4
        self.epsilon2 = 0.6
        self.maximum_tolerance_dalay = 20
        self.gamma = -1
        self.reward = 0

    def get_vehicle_density(self):
        '''
        range from[5.0,40.0]
        @param b: the number of station
        @return: the density of vehicle around each base station
        '''
        return np.random.uniform(40, 5, (self.b))

    def get_Gb(self):
        '''
        @return: available computing resource
        '''
        Gb = self.G_total - (self.Gb_bar + self.u * self.Vehicle_density)
        return Gb

    def get_Ntr(self):
        '''
        range from (0:10]
        @return: Ntr
        '''
        return np.array([8])

    def update_Ntr(self):
        # self.Ntr[0]+=np.random.randint(2,5)
        self.Ntr[0] = np.array([8])
        return

    def get_t_delay(self,task):
        '''
        range from[0.1,11]
        @param b: the number of station
        @return: the delay of base station
        '''
        #TODO: use the time stamp to get the delay of every

        return

    def get_normalized_utilization(self,Ib,task):
        '''
        @return: normalization_utilization
        '''
        difference = self.Tn[Ib] - task.delay
        if difference < 0:
            normalized_utility = 0
        else:
            normalized_utility = np.log(1 + difference) / np.log(1 + self.Tn[Ib])
        return normalized_utility

    def update_compute_efficiency(self, Ib,normalized_utilization):
        '''
        update the compute efficaiency according to normalized utility and previous compute efficiency
        @return:
        '''
        self.baseStations[Ib].computing_efficiency = (1 - self.omega1) * self.compute_efficiency[Ib] + self.omega1 * \
                                      normalized_utilization

        return

    # def update_total_received(self, Ib):
    #     self.total_received_task[Ib] += 1
    #     self.baseStations[Ib].total_received_task = self.total_received_task[Ib]
    #     self.baseStations[Ib].id = "BASESTATION" + str(Ib)
    #     # print("id:",self.baseStations[Ib].id)
    #     update(self.baseStations[Ib])
    #     return

    def update_completion_ratio(self, Ib,task):
        one = 1 if task.delay < self.Tn[Ib] else 0
        total_received_task = countAllByBS()
        total_done_task =countDoneByBS()
        self.baseStations[Ib].completion_ratio = (self.baseStations[Ib].total_received_task * self.completion_ratio[Ib] + one) / (
                self.total_received_task[Ib] + 1)
        self.baseStations[Ib].total_received_task+=1
        return

    def get_reliability(self, Ib):
        result = self.omega2 * self.baseStations[Ib].compute_efficiency + (1 - self.omega1) * self.baseStations[Ib].compute_efficiency
        self.baseStations[Ib].reliability = result
        return

    def update_reliability(self, Ib):

        #TODO:update the reliability as the update task lists
        self.get_normalized_utilization(Ib)
        self.update_compute_efficiency(Ib)
        self.update_completion_ratio(Ib)
        self.reliability[Ib] = self.get_reliability(Ib)
        self.baseStations[Ib].reliability = self.reliability[Ib]
        self.baseStations[Ib].id = "BASESTATION" + str(Ib)
        # print("id:", self.baseStations[Ib].id)
        update(self.baseStations[Ib])
        return

    def get_verify_time1(self):
        return np.random.uniform(15, 30)

    def get_verify_time2(self):
        return np.random.uniform(10, 21)

        # def get_reward(self,Ib,Sbk):

    def get_reward(self, Ib):
        Sbk = 8
        if Ib == 0:
            delay = self.get_verify_time1()
        else:
            delay = self.get_verify_time2()
        if delay > self.maximum_tolerance_dalay:
            self.reward = -5
        else:
            self.reward = (self.epsilon1 * self.baseStations[Ib].reliability + self.epsilon2 * Sbk / 2.0) * (
                    1 + self.maximum_tolerance_dalay - delay)
        self.reward = np.float(self.reward)
        return self.reward

    def updateBSByTasks(self,num):
        tasks = selectLatest(num)
        for task in tasks:
            Ib = task.allocation_basestation_id
            normalized_utilization = self.get_normalized_utilization(Ib,task)
            self.update_compute_efficiency(Ib,normalized_utilization)
            self.update_completion_ratio(Ib,task)
            self.get_reliability(Ib)
            update(self.baseStations[Ib])



